Сравнение производительности для двух логеров: [slog](https://github.com/slog-rs/slog) и
[fast_log](https://github.com/rbatis/fast_log).

Запуск сравнения осуществляется командой `cargo bench`

У меня результат примерно такой:
```
fast log benchmark/fast_log                                                                             
                        time:   [3.5352 us 3.5765 us 3.6174 us]
                        change: [-2.9781% -1.8605% -0.6066%] (p = 0.00 < 0.05)
                        Change within noise threshold.
Found 127 outliers among 500 measurements (25.40%)
  98 (19.60%) low severe
  3 (0.60%) low mild
  16 (3.20%) high mild
  10 (2.00%) high severe

fast log benchmark/slog time:   [4.5779 us 4.5834 us 4.5896 us]                                     
                        change: [-1.7298% -1.3812% -1.0127%] (p = 0.00 < 0.05)
                        Performance has improved.
Found 27 outliers among 500 measurements (5.40%)
  1 (0.20%) low severe
  6 (1.20%) low mild
  16 (3.20%) high mild
  4 (0.80%) high severe
```

(обращать внимание нужно на 3.5765 us и 4.5834 us, где us - это микросекунды)

И тот и другой логер умеют писать в асинхронном фоновом процессе, т.е. при соблюдении определенных условий это 
не блокирующая операция, оба достаточно быстрые, но slog (более известный и популярный) давно не обновлялся, 
последняя версия [2.7](https://crates.io/crates/slog) от 30 ноября 2020.

fast_log активно развивается и его последняя версия [1.3.32](https://crates.io/crates/fast_log) от 26 сентября 2021.

По производительности результаты в пользу fast_log, примерно на 1 микросекунду он отрабатывает быстрее, 
если в относительных величинах, то на 20% быстрее.

Вроде и не существенно, но это смотря в каких проектах. В моем новом рабочем проекте достаточно серьезные требования по 
быстродействию и экономия даже десятых долей микросекунды на одну запись в лог имеет значение. С учетом имеющегося 
бизнес требования обработать входные данные и формировать отклик за 50 микросекунд, это существенная экономия.

Еще один плюс fast_log в том, что его очень просто инициализировать. Может быть, он не такой гибкий как slog, 
я пока не нашел аналога OverflowStrategy, т.е. в fast_log, скорее всего, одна жестко закрепленная стратегия* 
(аналог OverflowStrategy::Block для slog), но он вполне удобный и возможностей там хватает.

*Это не точно.
