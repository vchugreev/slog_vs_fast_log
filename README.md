Сравнение производительности для двух логеров: [slog](https://github.com/slog-rs/slog) и
[fast_log](https://github.com/rbatis/fast_log).

Запуск сравнения осуществляется командой `cargo bench`

У меня результат примерно такой:
```
fast log benchmark/fast_log                                                                             
                        time:   [3.9130 us 3.9197 us 3.9284 us]
                        change: [-2.7701% -2.4518% -2.0931%] (p = 0.00 < 0.05)
                        Performance has improved.
Found 11 outliers among 100 measurements (11.00%)
  3 (3.00%) low mild
  5 (5.00%) high mild
  3 (3.00%) high severe
  
fast log benchmark/slog time:   [4.5457 us 4.5544 us 4.5642 us]                                     
                        change: [-1.7586% -1.3000% -0.6646%] (p = 0.00 < 0.05)
                        Change within noise threshold.
Found 5 outliers among 100 measurements (5.00%)
  2 (2.00%) low mild
  1 (1.00%) high mild
  2 (2.00%) high severe

```

(обращать внимание нужно на 3.9197 us и 4.5544 us, где us - это микросекунды)

И тот и другой логер умеют писать в асинхронном фоновом процессе, т.е. при соблюдении определенных условий это 
не блокирующая операция, оба достаточно быстрые, но slog (более известный и популярный) давно не обновлялся, 
последняя версия [2.7](https://crates.io/crates/slog) от 30 ноября 2020.

fast_log активно развивается и его последняя версия [1.3.32](https://crates.io/crates/fast_log) от 26 сентября 2021.

По производительности результаты в пользу fast_log, примерно на 0.5 микросекунды он отрабатывает быстрее, 
если в относительных величинах, то на 12.5% быстрее.

Вроде и не существенно, но это смотря в каких проектах. В моем новом рабочем проекте достаточно серьезные требования по 
быстродействию и экономия даже десятых долей микросекунды на одну запись в лог имеет значение. С учетом имеющегося 
бизнес требования обработать входные данные и формировать отклик за 50 микросекунд, это существенная экономия.

Еще один плюс fast_log в том, что его очень просто инициализировать. Может быть, он не такой гибкий как slog, 
я пока не нашел аналога OverflowStrategy, т.е. в fast_log, скорее всего, одна жестко закрепленная стратегия* 
(аналог OverflowStrategy::Block для slog), но он вполне удобный и возможностей там хватает.

*Это не точно.
