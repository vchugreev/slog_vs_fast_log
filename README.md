Сравнение производительности для двух логеров: [slog](https://github.com/slog-rs/slog) и
[fast_log](https://github.com/rbatis/fast_log).

Запуск сравнения осуществляется командой `cargo bench`

У меня результат примерно такой:
```
fast log benchmark/fast_log                                                                            
                        time:   [292.75 us 293.61 us 294.48 us]
                        change: [-2.1167% -1.7889% -1.4600%] (p = 0.00 < 0.05)
                        Performance has improved.
Found 2 outliers among 100 measurements (2.00%)
  2 (2.00%) high mild

fast log benchmark/slog time:   [447.38 us 448.03 us 448.71 us]                                    
                        change: [-0.3140% -0.1253% +0.0597%] (p = 0.21 > 0.05)
                        No change in performance detected.
```

(обращать внимание нужно на 293.61 us и 448.03 us, где us - это микросекунды)

И тот и другой логер умеют писать в асинхронном фоновом процессе, т.е. при соблюдении определенных условий это 
не блокирующая операция, оба достаточно быстрые, но slog (более известный и популярный) давно не обновлялся, 
последняя версия [2.7](https://crates.io/crates/slog) от 30 ноября 2020.

fast_log активно развивается и его последняя версия [1.3.32](https://crates.io/crates/fast_log) от 26 сентября 2021.

По производительности результаты в пользу fast_log, в рамках данного замера он отрабатывает примерно на 150 микросекунд 
быстрее, если в относительных величинах, то примерно на 30% быстрее.

Еще один плюс fast_log в том, что его очень просто инициализировать. Может быть, он не такой гибкий как slog, 
я пока не нашел аналога OverflowStrategy, т.е. в fast_log, скорее всего, одна жестко закрепленная стратегия* 
(аналог OverflowStrategy::Block для slog), но он вполне удобный и возможностей там хватает.

*Это не точно.

### Примечание

Возможно, что ваше железо существенно лучше, чем то, на чем я проверял производительность и тогда вы не увидите разницу. 
В этом случае можно попробовать нагрузить систему и запустить бенчмарки уже на нагруженной системе. 

Самый простой способ создать нагрузку через stress. Достаточно нагрузить CPU: `stress --cpu 12` (у меня 12 ядерный 
процессор, поэтому такое значение).