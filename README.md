Сравнение производительности для двух логеров: [slog](https://github.com/slog-rs/slog) и
[fast_log](https://github.com/rbatis/fast_log).

Запуск сравнения осуществляется командой `cargo bench`

У меня результат примерно такой:
```
fast log benchmark/fast_log                                                                             
                        time:   [3.5352 us 3.5765 us 3.6174 us]
                        change: [-2.9781% -1.8605% -0.6066%] (p = 0.00 < 0.05)
                        Change within noise threshold.
Found 127 outliers among 500 measurements (25.40%)
  98 (19.60%) low severe
  3 (0.60%) low mild
  16 (3.20%) high mild
  10 (2.00%) high severe

fast log benchmark/slog time:   [4.5779 us 4.5834 us 4.5896 us]                                     
                        change: [-1.7298% -1.3812% -1.0127%] (p = 0.00 < 0.05)
                        Performance has improved.
Found 27 outliers among 500 measurements (5.40%)
  1 (0.20%) low severe
  6 (1.20%) low mild
  16 (3.20%) high mild
  4 (0.80%) high severe
```

(обращать внимание нужно на 3.5765 us и 4.5834 us, где us - это микросекунды)

И тот и другой логер умеют писать в асинхронном фоновом процессе, т.е. при соблюдении определенных условий это 
не блокирующая операция, оба достаточно быстрые, но slog (более известный и популярный) давно не обновлялся, 
последняя версия [2.7](https://crates.io/crates/slog) от 30 ноября 2020.

fast_log активно развивается и его последняя версия [1.3.32](https://crates.io/crates/fast_log) от 26 сентября 2021.

По производительности результаты в пользу fast_log, примерно на 1 микросекунду он отрабатывает быстрее, 
если в относительных величинах, то на 20% быстрее.

Вроде и не существенно, но это смотря в каких проектах. В моем новом рабочем проекте достаточно серьезные требования по 
быстродействию и экономия даже десятых долей микросекунды на одну запись в лог имеет значение. С учетом имеющегося 
бизнес требования обработать входные данные и формировать отклик за 50 микросекунд, это существенная экономия.

Еще один плюс fast_log в том, что его очень просто инициализировать. Может быть, он не такой гибкий как slog, 
я пока не нашел аналога OverflowStrategy, т.е. в fast_log, скорее всего, одна жестко закрепленная стратегия* 
(аналог OverflowStrategy::Block для slog), но он вполне удобный и возможностей там хватает.

*Это не точно.

### Примечание

Возможно, что ваше железо существенно лучше, чем то, на чем я проверял производительность и тогда вы не увидите разницу. 
К примеру коллега проверял это на своей машине и получилось примерно 1.6 us для каждого логера. В этом случае можно 
попробовать нагрузить систему и запустить бенчмарки уже на нагруженной системе. 

Самый простой способ создать нагрузку через stress. Думаю, что достаточно нагрузить CPU: `stress --cpu 12` Лично у меня 
под нагрузкой получаются такие результаты:

```
fast log benchmark/fast_log                                                                             
                        time:   [5.3373 us 5.5416 us 5.7494 us]
                        change: [-4.5790% +1.2830% +7.5140%] (p = 0.67 > 0.05)
                        No change in performance detected.
Found 5 outliers among 500 measurements (1.00%)
  4 (0.80%) high mild
  1 (0.20%) high severe

fast log benchmark/slog time:   [9.5734 us 9.7189 us 9.8566 us]                                     
                        change: [-14.894% -11.213% -7.7061%] (p = 0.00 < 0.05)
                        Performance has improved.
Found 68 outliers among 500 measurements (13.60%)
  20 (4.00%) low severe
  27 (5.40%) low mild
  11 (2.20%) high mild
  10 (2.00%) high severe
```

Разница в производительности уже почти в два раза, т.е. вариант с fast_log приблизительно на 50% быстрее. Однако 
утверждать это наверняка я все же не берусь, подобная методика тестирования не очень надежна. Похоже, что fast_log 
действительно быстрее, но насколько быстрее сказать сложно. Также сложно представить надежные, воспроизводимые на 
разном железе бенчмарки.